#  T1-题目集锦

## L1-1004 成绩排名

```c++
#include<iostream>
#include<cmath>
using namespace std;

struct stu
{
  string name;
  string num;
  int score;
};

int main()
{
  stu students[1000];
  int n;
  cin >> n;
  for(int i = 0; i < n; i++)
    {
      cin >> students[i].name 
	  >> students[i].num
	  >> students[i].score;
    }
  int maxl = students[0].score;
      int minn = students[0].score;
  int t=0, j=0;
  for(int i = 1; i < n; i++)
    {
      if(maxl < students[i].score)
      {
          maxl = students[i].score;
          t = i;
      }
      if(minn > students[i].score)
      {
          minn = students[i].score;
          j = i;
      }
    }
 cout << students[t].name << " " << students[t].num << endl
       << students[j].name << " " << students[j].num;
}

```

**对于结构体变量中要准确区分，哪个是结构体和结构体成员。在代码中‘students’相当与结构体数组，‘students[i]'为此数组的索引值。我在用这个结构体时我把索引加到了结构体的成员变量后面导致的编译错误，犯下了这个低级错误，可能是我太久未用结构体的缘故吧，现在捡回来了。**

## L1-1009 说反话

## 代码块

```c++
#include<iostream>
#include<stack>
using namespace std;
int main()
{
  string sen;
  stack<string> word;
  while(cin >> sen)
      word.push(sen);
  int t = 0;
  while(!word.empty())
    {
        cout << (t==0?"":" ")<< word.top();
        t++;
      	word.pop();
    }
}
```

本题就是纯粹靠stack的结构特性——先进后出来输出反转字符串。学到了！！！



## stack容器适配器的创建

由于 stack 适配器以模板类 stack<T,Container=deque<T>>（其中 T 为存储元素的类型，Container 表示底层容器的类型）的形式位于<stack>头文件中，并定义在 std 命名空间里。因此，在创建该容器之前，程序中应包含以下 2 行代码：

```
#include <stack>using namespace std;
```

> std 命名空间也可以在使用 stack 适配器时额外注明。

创建 stack 适配器，大致分为如下几种方式。

1) 创建一个不包含任何元素的 stack 适配器，并采用默认的 deque 基础容器：

```
std::stack<int> values;
```

上面这行代码，就成功创建了一个可存储 int 类型元素，底层采用 deque 基础容器的 stack 适配器。

2) 上面提到，stack<T,Container=deque<T>> 模板类提供了 2 个参数，通过指定第二个模板类型参数，我们可以使用出 deque 容器外的其它序列式容器，只要该容器支持 empty()、size()、back()、push_back()、pop_back() 这 5 个成员函数即可。


在介绍适配器时提到，序列式容器中同时包含这 5 个成员函数的，有 vector、deque 和 list 这 3 个容器。因此，stack 适配器的基础容器可以是它们 3 个中任何一个。例如，下面展示了如何定义一个使用 list 基础容器的 stack 适配器：

```
std::stack<std::string, std::list<int>> values;
```

3) 可以用一个基础容器来初始化 stack 适配器，只要该容器的类型和 stack 底层使用的基础容器类型相同即可。例如：



```
std::list<int> values {1, 2, 3};std::stack<int,std::list<int>> my_stack (values);
```

注意，初始化后的 my_stack 适配器中，栈顶元素为 3，而不是 1。另外在第 2 行代码中，stack 第 2 个模板参数必须显式指定为 list<int>（必须为 int 类型，和存储类型保持一致），否则 stack 底层将默认使用 deque 容器，也就无法用 lsit 容器的内容来初始化 stack 适配器。

4) 还可以用一个 stack 适配器来初始化另一个 stack 适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可。例如：



```
std::list<int> values{ 1, 2, 3 };std::stack<int, std::list<int>> my_stack1(values);std::stack<int, std::list<int>> my_stack=my_stack1;//std::stack<int, std::list<int>> my_stack(my_stack1);
```

可以看到，和使用基础容器不同，使用 stack 适配器给另一个 stack 进行初始化时，有 2 种方式，使用哪一种都可以。

> 注意，第 3、4 种初始化方法中，my_stack 适配器的数据是经过拷贝得来的，也就是说，操作 my_stack 适配器，并不会对 values 容器以及 my_stack1 适配器有任何影响；反过来也是如此。

## stack容器适配器支持的成员函数

和其他序列容器相比，stack 是一类存储机制简单、提供成员函数较少的容器。表 1 列出了 stack 容器支持的全部成员函数。

| 成员函数                     | 功能                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| empty()                      | 当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false。 |
| size()                       | 返回 stack 栈中存储元素的个数。                              |
| top()                        | 返回一个栈顶元素的引用，类型为 T&。如果栈为空，程序会报错。  |
| push(const T& val)           | 先复制 val，再将 val 副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。 |
| push(T&& obj)                | 以移动元素的方式将其压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。 |
| pop()                        | 弹出栈顶元素。                                               |
| emplace(arg...)              | arg... 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素。 |
| swap(stack<T> & other_stack) | 将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 |

## L1-10012 数字分类

## 代码块

```c++
#include <stdio.h>
int main() {
    int x1 = 0, x2 = 0, x3 = 0, x4 = 0, x5 = 0;
    int x2flag = 0, x4count = 0;
    
    int count; scanf("%d", &count);
 
    for(int i = 0, n; i < count; i++) {
        scanf("%d", &n);
        switch(n % 5) {
            case 0: x1 += n % 2 ? 0 : n;                                break;
            case 1: x2flag = x2flag == 1 ? -1 : 1; x2 += x2flag * n;    break;
            case 2: x3 ++;                                              break;
            case 3: x4 += n; x4count ++;                                break;
            case 4: x5 = n > x5? n : x5;                                break;
        }
    }
 
    if(x1 == 0)     printf("N ");   else printf("%d ", x1);
    if(x2flag == 0) printf("N ");   else printf("%d ", x2);
    if(x3 == 0)     printf("N ");   else printf("%d ", x3);
    if(x4 == 0)     printf("N ");   else printf("%.1f ", x4 * 1.0 / x4count);
    if(x5 == 0)     printf("N");    else printf("%d", x5);
 
return 0; }

```

**使用switch循环简化代码长度，巧用三目运算符使代码更简洁！**